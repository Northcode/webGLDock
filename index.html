<html>

    <head>
	<meta charset="utf-8">
	<style>
	    body { margin: 0; }
	    canvas { width: 100%; height: 100%; }
	</style>
    </head>
    
    <body>
	<script src="three.js"></script>
	<script src="threex.keyboardstate.js"></script>
	<script src="threex.loop.js"></script>
	<script src="OrbitControls.js"></script>
	<script>

	    'use strict';


	 const shadowMapRes = 4096;
	 const deg_to_rad = (deg) => deg * (Math.PI / 180);

	 // SCENE
	 let scene = new THREE.Scene();
	 scene.background = new THREE.Color(0x3d8dcc);

	 // CAMERA
	 let camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );


	 // RENDERER
	 let renderer = new THREE.WebGLRenderer();
	 renderer.setSize( window.innerWidth, window.innerHeight );
	 document.body.appendChild( renderer.domElement );

	 renderer.shadowMap.enabled = true;
	 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	 renderer.shadowMap.renderReverseSided = false;

	 renderer.gammaInput = true;
	 renderer.gammaOutput = true;

	 // LIGHTING
	 let light = new THREE.DirectionalLight(0xffffff, 1, 100);
	 light.position.set(0,20,0);
	 light.shadow.mapSize.width = shadowMapRes;
	 light.shadow.mapSize.height = shadowMapRes;
	 light.shadow.camera.near = 0.5;
	 light.shadow.camera.far = 500;
	 light.castShadow = true;

	 scene.add(light);

	 // AMBIENT LIGHT
	 let ambient = new THREE.AmbientLight(0x404040);
	 scene.add(ambient);


	 // CUBE
	 let cube = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshPhongMaterial( { color: 0x00ff00, specular: 0xffffff, shininess: 20, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) );
	 cube.castShadow = true;
	 scene.add( cube );

	 // GROUND
	 let ground = new THREE.Mesh(new THREE.PlaneBufferGeometry ( 1000, 1000 , 10, 10), new THREE.MeshPhongMaterial( { color: 0x0000ff, specular: 0x050505 } ));
	 ground.rotation.set(deg_to_rad(270),0,0);
	 ground.position.set(0,-5,0);
	 scene.add(ground);

	 ground.receiveShadow = true;

	 // TRACKS
	 let texLoader = new THREE.TextureLoader();
	 let jloader = new THREE.JSONLoader();

	 let tracks = null;

	 const load_file = (model_f, tex_f) => {
	     return new Promise((resolve,reject) => {
		 jloader.load(model_f, (geometry, mats) => {
		     tracks = new THREE.Mesh(geometry, mats);
		     texLoader.load(tex_f, (texture) => {
			 let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial({map: texture, flatShading: true, shininess: 0, specular: 0x000, morphTargets: true, vertexColors: THREE.FaceColors }) );
			 resolve(mesh);
		     }, (progress) => {}, (error) => reject(error));
		 });
	     }, (prog) => {}, (err) => reject(error));
	 };

	 let tracksP = load_file ("tracks.json", "TracksUVs.png");

	 tracksP.then(t => {
	     t.position.set(0,-5,0);
	     t.receiveShadow = true;
	     t.geometry.computeBoundingBox();
	     let size = t.geometry.boundingBox.max.z - t.geometry.boundingBox.min.z
	     cube.add(t);
	     for (let i = 1; i < 5; i++) {
		 let ex = t.clone();
		 ex.position.z += size * i
		 cube.add(ex);
	     }
	 });
	 
	 // POSITION CAMERA
	 camera.position.z = 5;
	 camera.position.y = 0.5;

	 camera.lookAt(cube.position);


	 // ORBIT CONTROLS
	 let controls = new THREE.OrbitControls( camera, renderer.domElement );

	 // KEYBOARD
	 let keyboard = new THREEx.KeyboardState();

	 let cube2 = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff, shininess: 20, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) );
	 cube2.position.x = 1;

	 // ANIM LOOP
	 const animate = () => {
	     renderer.render(scene, camera);
	 };

	 const update = () => {
	     if (keyboard.pressed("A")) {
		 console.log("AAAAAAAAAAAAAAAAAAAAAA!");
		 cube.add(cube2);
	     }
	     if (keyboard.pressed("S")) {
		 console.log("SSSSSSSSSSSSSSSSssssSSSSSs!");
		 cube.remove(cube2);
	     }
	 };

	 let animLoop = new THREEx.RenderingLoop();
	 let physLoop = new THREEx.PhysicsLoop(60);

	 animLoop.add(animate);

	 physLoop.add(update);
	 
	 animLoop.start();
	 physLoop.start();
	 

	</script>
    </body>
    
</html>
