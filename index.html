<html>

    <head>
	<meta charset="utf-8">
	<style>
	    body { margin: 0 }
	    canvas { width: 100% height: 100% }
	</style>
    </head>
    
    <body>
	<script src="lib/three.js"></script>
	<script src="lib/threex.keyboardstate.js"></script>
	<script src="lib/threex.loop.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script>
	 const shadowMapRes = 4096
	 const deg_to_rad = (deg) => deg * (Math.PI / 180)

	 // SCENE
	 let scene = new THREE.Scene()
	 scene.background = new THREE.Color(0x3d8dcc)

	 // CAMERA
	 let camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 )

	 // RENDERER
	 let renderer = new THREE.WebGLRenderer()
	 renderer.setSize( window.innerWidth, window.innerHeight )
	 document.body.appendChild( renderer.domElement )

	 renderer.shadowMap.enabled = true
	 renderer.shadowMap.type = THREE.PCFSoftShadowMap
	 renderer.shadowMap.renderReverseSided = false

	 renderer.gammaInput = true
	 renderer.gammaOutput = true

	 // LIGHTING
	 let light = new THREE.DirectionalLight(0xffffff, 1, 100)
	 light.position.set(0,30,0)
	 light.shadow.mapSize.width = shadowMapRes
	 light.shadow.mapSize.height = shadowMapRes
	 /* light.shadow.camera = new THREE.PerspectiveCamera( 45, 1000, 1000, 0.1, 1000)*/
	 light.shadow.camera.left = -30
	 light.shadow.camera.right = 80
	 light.shadow.camera.top = 50
	 light.shadow.camera.bottom = -50
	 light.shadow.camera.near = 1
	 light.shadow.camera.far = 50
	 
	 light.castShadow = true

	 scene.add(light)

	 // AMBIENT LIGHT
	 let ambient = new THREE.AmbientLight(0x404040)
	 scene.add(ambient)

	 
	 let shadowHelper = new THREE.CameraHelper(light.shadow.camera)
	 scene.add(shadowHelper)


	 // CUBE
	 let cube = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshPhongMaterial( { color: 0x00ff00, specular: 0xffffff, shininess: 20, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) )
	 cube.castShadow = true
	 cube.position.set(8,10,0)
	 cube.scale.set(2,2,2)
	 scene.add( cube )

	 // OCEAN
	 let ocean = new THREE.Mesh(new THREE.PlaneBufferGeometry ( 1000, 1000 , 10, 10), new THREE.MeshPhongMaterial( { color: 0x0000ff, specular: 0x050505 } ))
	 ocean.rotation.set(deg_to_rad(270),0,0)
	 ocean.position.set(0,-2,0)
	 scene.add(ocean)
	 ocean.receiveShadow = true

	 // DOCK
	 let dock = new THREE.Mesh( new THREE.BoxBufferGeometry( 50, 1, 100 ), new THREE.MeshPhongMaterial( { color: 0xBA4E0E, specular: 0x999999, shininess: 1, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) )
	 let dockSurface = new THREE.Object3D()
	 dockSurface.position.set(0,0.5,0)
	 dock.castShadow = false
	 dock.receiveShadow = true
	 dock.add(dockSurface)
	 scene.add( dock )


	 // INIT PICK UP-ABLE OBJECT LIST
	 let pickupableobjects = []
	 pickupableobjects.push(cube)


	 let texLoader = new THREE.TextureLoader()
	 let jloader = new THREE.JSONLoader()

	 const load_file = (model_f, tex_f) => {
	     return new Promise((resolve,reject) => {
		 jloader.load(model_f, (geometry, mats) => {
		     texLoader.load(tex_f, (texture) => {
			 let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial({map: texture, flatShading: true, shininess: 0, specular: 0x000, morphTargets: true, vertexColors: THREE.FaceColors }) )
			 resolve(mesh)
		     }, (progress) => {}, (error) => reject(error))
		 })
	     }, (prog) => {}, (err) => reject(error))
	 }

	 // LOAD MODELS AND TEXTURES
	 let tracksP = load_file("models/tracks.json",   "textures/TracksUVs.png")
	 let craneP =  load_file("models/craneBase.json","textures/craneBaseUVs.png")
	 let clockTowerP =  load_file("models/clockTower2.json","textures/clockTower2.png")
	 let boatP =  load_file("models/boat.json","textures/boatUVs.png")
	 let crateP =  load_file("models/crate.json","textures/crate.png")
	 let house1P =  load_file("models/house1.json","textures/house1UVs.png")
	 let factoryP =  load_file("models/factory.json","textures/factory.png")

	 let tracks = new THREE.Object3D()
	 const track_length = 7
	 let track_size = 0

	 tracksP.then(t => {
	     tracks.position.set(20,0,-45)
	     tracks.receiveShadow = true
	     t.geometry.computeBoundingBox()
	     track_size = t.geometry.boundingBox.max.z - t.geometry.boundingBox.min.z
	     tracks.add(t)
	     for (let i = 1; i <= track_length; i++) {
		 let ex = t.clone()
		 ex.position.z += track_size * i
		 tracks.add(ex)
	     }
	     dockSurface.add(tracks)
	 })

	 let crane = null
	 let craneArm1 = null
	 let craneArm2 = null
	 let craneGrab = new THREE.Object3D()

	 craneP.then(m => {
	     m.scale.set(1.2,1,1.2)
	     m.position.set(0,0,0)
	     m.receiveShadow = true
	     crane = m

	     let arm1 = new THREE.Mesh( new THREE.BoxGeometry (1,8,1),
					new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff, shininess: 15, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true }))

	     let pivot1 = new THREE.Object3D()
	     arm1.position.set(0,3.8,0)
	     pivot1.add(arm1)
	     pivot1.position.set(0,1,0)
	     craneArm1 = pivot1
	     arm1.castShadow = true

	     let arm2 = new THREE.Mesh( new THREE.BoxGeometry (1,8,1),
					new THREE.MeshPhongMaterial( { color: 0x00ff00, specular: 0xffffff, shininess: 15, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true }))

	     let joint = new THREE.Mesh( new THREE.CylinderGeometry(0.8,0.8,1.3,15), 
					 new THREE.MeshPhongMaterial( { color: 0x222222, specular: 0xffffff, shininess: 15, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true }))

	     let pivot2 = new THREE.Object3D()
	     arm2.position.set(0,3.8,0)
	     pivot2.add(arm2)
	     pivot2.position.set(0,7.6,0)
	     pivot2.rotation.z = deg_to_rad(70)
	     craneArm2 = pivot2
	     arm2.castShadow = true

	     joint.position.set(0,7.6,0)
	     joint.rotation.x = deg_to_rad(90)

	     craneArm1.add(joint)
	     craneArm1.add(craneArm2)

	     craneGrab.position.set(0,8,0)
	     craneArm2.add(craneGrab)

	     let dir = craneGrab.getWorldPosition().sub(craneArm2.getWorldPosition()).normalize()
	     let arrow = new THREE.ArrowHelper(dir, craneGrab.position, 2, 0xeeeeee)

	     craneArm2.add(arrow)

	     crane.add(craneArm1)
	     tracks.add(crane)
	 })

	 let hourHand = null
	 let minuteHand = null

	 clockTowerP.then(ct => {
	     ct.position.set(10,0,10)
	     ct.castShadow = true

	     let clock = new THREE.Object3D()

	     let hourPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry ( 0.5, 0.1 , 10, 10), new THREE.MeshPhongMaterial( { color: 0x0000ff, specular: 0x050505 } ))

	     let hourPivot = new THREE.Object3D()
	     
	     clock.position.set(2.7,18,0)
	     hourPlane.rotateY(deg_to_rad(90))
	     hourPlane.position.set(0,0,-0.3)
	     
	     hourPivot.rotateX(deg_to_rad(90))

	     hourPivot.rotateX(deg_to_rad(-60))
	     hourPivot.add(hourPlane)

	     hourHand = hourPivot

	     let minutePlane = new THREE.Mesh(new THREE.PlaneBufferGeometry ( 0.9, 0.1 , 10, 10), new THREE.MeshPhongMaterial( { color: 0x0000ff, specular: 0x050505 } ))

	     let minutePivot = new THREE.Object3D()
	     
	     clock.position.set(2.7,18,0)
	     minutePlane.rotateY(deg_to_rad(90))
	     minutePlane.position.set(0,0,-0.3)
	     
	     minutePivot.rotateX(deg_to_rad(90))

	     minutePivot.rotateX(deg_to_rad(0))
	     minutePivot.add(minutePlane)

	     minuteHand = minutePivot
	     
	     clock.add(hourPivot)
	     clock.add(minutePivot)
	     ct.add(clock)
	 	 pickupableobjects.push(ct)
	     scene.add(ct)
	 })

	 boatP.then(mesh => {
	     mesh.position.set(35, -2, 0)
	     mesh.scale.set(2,2,4)
	     mesh.receiveShadow = true
	     pickupableobjects.push(mesh)
	     scene.add(mesh)
	 })

	 let crateProto = null
	 
	 crateP.then(mesh => {
	     mesh.scale.set(2,2,2)
	     mesh.castShadow = true
	     crateProto = mesh.clone()
	     mesh.position.set(10,0,-15)

	     pickupableobjects.push(mesh)
	     dockSurface.add(mesh)
	 })

	 house1P.then(mesh => {
	     mesh.position.set(0,0,10)
	     mesh.castShadow = true
	     scene.add(mesh)
	 })

	 let factory = new THREE.Object3D()
	 let crateSpawn = new THREE.Object3D()
	 let crateLocation = new THREE.Object3D()

	 factoryP.then(mesh => {
	     mesh.castShadow = true
	     factory.add(mesh)

	     factory.position.set(-5,0,-35)
	     factory.rotateY(deg_to_rad(-90))
	     mesh.scale.set(2,2,2)

	     crateSpawn.position.set(0,0,-6)

	     let testCube = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshPhongMaterial( { color: 0x00ff00, specular: 0xffffff, shininess: 20, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) )

	     crateSpawn.rotateY(deg_to_rad(90))
	     crateSpawn.add(testCube)

	     crateLocation.position.set(0,0,-30)

	     factory.add(crateSpawn)
	     factory.add(crateLocation)
	     
	     scene.add(factory)
	 })

	 
	 // POSITION CAMERA
	 camera.position.x = 40
	 camera.position.y = 20

	 camera.lookAt(cube.position)


	 // ORBIT CONTROLS
	 let controls = new THREE.OrbitControls( camera, renderer.domElement )

	 // KEYBOARD
	 let keyboard = new THREEx.KeyboardState()

	 let cube2 = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff, shininess: 20, morphTargets: true, vertexColors: THREE.FaceColors, flatShading: true } ) )
	 cube2.position.x = 1

	 // ANIM LOOP
	 const animate = () => {
	     renderer.render(scene, camera)
	 }

	 let arrow = null

	 let collidableMeshList = []
	 collidableMeshList.push(cube)

	 let dir = 1
	 
	 let newCrate = null
	 let moveCrate = false
	 
	 const update = () => {
	     cube.rotation.x += 0.01
	     cube.rotation.y += 0.01
	     cube.rotation.z += 0.01

	     if (cube.scale.x > 3) {
		 dir = -1
	     } else if (cube.scale.x < 0.25) {
		 dir = 1
	     }

	     cube.scale.x += 0.05 * dir
	     cube.scale.y += 0.05 * dir
	     cube.scale.z += 0.05 * dir

	     if (newCrate != null && moveCrate) {
		 newCrate.position.lerp(new THREE.Vector3(8,0,0), 0.08)
	     }
	     // Update clock

	     if (hourHand != null && minuteHand != null) {
		 let timenow = new Date()
		 hourHand.rotation.x = deg_to_rad(-(((timenow.getHours() % 12) / 12) * 360)
						- ((timenow.getMinutes() / 60) * (360/12))
						+ 90)
		 minuteHand.rotation.x = deg_to_rad(-(((timenow.getMinutes() % 60) / 60) * 360)
						  + 90)
	     }

	     const cranespeed = 0.3
	     const armspeed = 1

	     if (keyboard.pressed("J") && crane.position.z < track_length * track_size) {
		 crane.position.z += cranespeed
	     }
	     if (keyboard.pressed("L") && crane.position.z > 0) {
		 crane.position.z -= cranespeed
	     }
	     if (keyboard.pressed("A") && craneArm1.rotation.z < deg_to_rad(60)) {
		 craneArm1.rotation.z += deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("D") && craneArm1.rotation.z > deg_to_rad(-60)) {
		 craneArm1.rotation.z -= deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("W") && craneArm2.rotation.z < deg_to_rad(120)) {
		 craneArm2.rotation.z += deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("S") && craneArm2.rotation.z > deg_to_rad(-120)) {
		 craneArm2.rotation.z -= deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("Q")) {
		 craneArm1.rotation.y += deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("E")) {
		 craneArm1.rotation.y -= deg_to_rad(armspeed)
	     }
	     if (keyboard.pressed("F")) {

		 moveCrate = false
		 
		 let dirvec = craneGrab.getWorldPosition().sub(craneArm2.getWorldPosition()).normalize()
		 let raycast = new THREE.Raycaster(craneGrab.getWorldPosition().clone(), dirvec)


		 let arrow = new THREE.ArrowHelper(raycast.ray.direction.normalize(), raycast.ray.origin, 10, 0xff0000)
		 scene.add(arrow)

		 let intersects = raycast.intersectObjects(pickupableobjects)


		 if (intersects.length > 0 && intersects[0].distance < 10) {
		     console.log("HIT")
		     let obj = intersects[0].object
		     obj.position.set(0,0,0)
		     scene.remove(obj)
		     craneGrab.add(obj)
		 }
	     }
	     if (keyboard.pressed("G")) {
		 if (craneGrab.children.length > 0) {
		     let newpos = craneGrab.getWorldPosition().clone()

		     let obj = craneGrab.children[0]
		     craneGrab.remove(obj)
		     console.log(newpos)
		     scene.add(obj)
		     obj.position.copy(newpos)
		     /* obj.position.set(0,0,0)*/
		     console.log(obj)
		 }
	     }
	     if (keyboard.pressed("V")) {
		 if (newCrate == null) {

		     newCrate = crateProto.clone()
		     moveCrate = true

		     crateSpawn.add(newCrate)

		     pickupableobjects.push(newCrate)
		 }
	     }
	 }

	 let animLoop = new THREEx.RenderingLoop()
	 let physLoop = new THREEx.PhysicsLoop(60)

	 animLoop.add(animate)

	 physLoop.add(update)
	 
	 animLoop.start()
	 physLoop.start()
	 

	</script>
    </body>
    
</html>
